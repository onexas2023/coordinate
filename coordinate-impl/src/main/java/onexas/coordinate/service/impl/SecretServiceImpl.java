package onexas.coordinate.service.impl;

import java.util.LinkedList;
import java.util.List;
import java.util.Optional;

import javax.crypto.SecretKey;

import org.apache.commons.codec.binary.Base64;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Direction;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Isolation;
import org.springframework.transaction.annotation.Transactional;

import com.fasterxml.jackson.core.type.TypeReference;

import onexas.coordinate.common.app.Env;
import onexas.coordinate.common.err.BadArgumentException;
import onexas.coordinate.common.err.NotFoundException;
import onexas.coordinate.common.lang.Strings;
import onexas.coordinate.common.model.ListPage;
import onexas.coordinate.common.util.Jsons;
import onexas.coordinate.common.util.Securitys;
import onexas.coordinate.data.CoordinateEntityManageConfiguration;
import onexas.coordinate.data.util.Fields;
import onexas.coordinate.model.Secret;
import onexas.coordinate.model.SecretCreate;
import onexas.coordinate.model.SecretFilter;
import onexas.coordinate.model.SecretUpdate;
import onexas.coordinate.service.AsyncExService;
import onexas.coordinate.service.LogService;
import onexas.coordinate.service.SecretService;
import onexas.coordinate.service.event.BeforeDeleteSecretEvent;
import onexas.coordinate.service.event.DeletedSecretEvent;
import onexas.coordinate.service.impl.dao.SecretEntityDao;
import onexas.coordinate.service.impl.dao.SecretEntityRepo;
import onexas.coordinate.service.impl.entity.SecretEntity;

/**
 * 
 * @author Dennis Chen
 *
 */
@Service(Env.NS_BEAN + "SecretServiceImpl")
public class SecretServiceImpl implements SecretService {

	private static final int UID_LOOP = 2;

	@Autowired
	SecretEntityRepo secretRepo;

	@Autowired
	SecretEntityDao secretDao;

	@Autowired
	ApplicationEventPublisher eventPublisher;

	@Autowired
	LogService logService;

	@Autowired
	AsyncExService asyncExService;

	/**
	 * the encode secret key which generated by
	 * {@link Securitys#generateSecretKey()}
	 */
	@Value("${coordinate.secret.encodedSecretKey:DESede Zw3yjFjckQuddqhhnrrjPrrpwu9Jj+mD}")
	String encodedSecretKey;

	// deferred
	SecretKey _secretKey;

	private SecretKey getSecretKey() {
		if (_secretKey == null) {
			_secretKey = Securitys.decodeSecretKey(encodedSecretKey);
		}
		return _secretKey;
	}

	@Override
	public ListPage<Secret> list(SecretFilter filter) {
		List<SecretEntity> list = new LinkedList<>();

		Direction direction = filter != null && Boolean.TRUE.equals(filter.getSortDesc()) ? Direction.DESC
				: Direction.ASC;

		Sort sort = Sort.by(direction, "code");
		Integer pageIndex = filter == null || filter.getPageIndex() == null ? 0 : filter.getPageIndex();
		Integer pageSize = filter == null || filter.getPageSize() == null ? Integer.MAX_VALUE : filter.getPageSize();
		Integer pageTotal = 1;
		Long itemTotal;

		if (filter == null) {
			list = secretRepo.findAll(sort);
			itemTotal = Long.valueOf(list.size());
		} else {
			String sortField = filter.getSortField();

			if (sortField != null) {
				Fields.checkFieldsIn(new String[] { sortField }, new String[] { "code", "createdDateTime" });
				sort = Sort.by(direction, sortField);
			}
			Pageable pageable = PageRequest.of(pageIndex, pageSize, sort);

			Page<SecretEntity> page = secretDao.findAll(filter, pageable);
			list = page.getContent();
			pageTotal = page.getTotalPages();
			itemTotal = page.getTotalElements();
		}

		return new ListPage<>(Jsons.transform(list, new TypeReference<List<Secret>>() {
		}), pageIndex, pageSize == null ? list.size() : pageSize, pageTotal, itemTotal);
	}

	@Override
	public Secret get(String uid) {
		Optional<SecretEntity> o = secretRepo.findById(uid);
		if (o.isPresent()) {
			return Jsons.transform(o.get(), Secret.class);
		}
		throw new NotFoundException("secret {} not found", uid);
	}

	@Override
	public Secret find(String uid) {
		Optional<SecretEntity> o = secretRepo.findById(uid);
		if (o.isPresent()) {
			return Jsons.transform(o.get(), Secret.class);
		}
		return null;
	}

	@Override
	@Transactional(transactionManager = CoordinateEntityManageConfiguration.TX_MANAGER, isolation = Isolation.READ_COMMITTED)
	public Secret create(SecretCreate secretCreate) {

		if (secretRepo.existsByUniqueConstraintCode(secretCreate.getCode())) {
			throw new BadArgumentException("the secret code {} is already existed ", secretCreate.getCode());
		}

		SecretEntity e = Jsons.transform(secretCreate, SecretEntity.class);

		e.setUid(Strings.randomUid(UID_LOOP));
		String ec = encryptContent(secretCreate.getContent());
		e.setEncryptedContent(ec);
		e.setFingerprint(ec == null ? null : Strings.trim(Securitys.md5String(e.getCode() + ec), 256));

		e = secretRepo.save(e);

		logService.info(getClass(), e.getUid(), Secret.class, null, null, "Created secret {}", e.getCode());

		return Jsons.transform(e, Secret.class);
	}

	private String encryptContent(String content) {
		if (content != null) {
			byte[] bytes = content.getBytes(Strings.UTF8);
			bytes = Securitys.encrypt(bytes, getSecretKey());
			content = Base64.encodeBase64String(bytes);
		}
		return content;
	}

	private String decryptContent(String content) {
		if (content != null) {
			byte[] bytes = Base64.decodeBase64(content);
			bytes = Securitys.decrypt(bytes, getSecretKey());
			content = new String(bytes, Strings.UTF8);
		}
		return content;
	}

	@Override
	@Transactional(transactionManager = CoordinateEntityManageConfiguration.TX_MANAGER, isolation = Isolation.READ_COMMITTED)
	public Secret update(String uid, SecretUpdate secretUpdate) {

		Optional<SecretEntity> o = secretRepo.findById(uid);
		if (o.isPresent()) {
			SecretEntity e = o.get();

			if (secretUpdate.getContent() != null) {
				String ec = encryptContent(secretUpdate.getContent());
				e.setEncryptedContent(ec);
				e.setFingerprint(ec == null ? null : Strings.trim(Securitys.md5String(e.getCode() + ec), 256));
			}
			if (secretUpdate.getDescription() != null) {
				e.setDescription(secretUpdate.getDescription());
			}

			e = secretRepo.save(e);

			logService.info(getClass(), e.getUid(), Secret.class, null, null, "Updated secret {}", e.getCode());

			Secret secret = Jsons.transform(e, Secret.class);
			return secret;
		} else {
			throw new BadArgumentException("secret {} not found", uid);
		}
	}

	@Override
	@Transactional(transactionManager = CoordinateEntityManageConfiguration.TX_MANAGER, isolation = Isolation.READ_COMMITTED)
	public void delete(String uid, boolean quiet) {
		Optional<SecretEntity> o = secretRepo.findById(uid);

		if (!o.isPresent()) {
			if (!quiet) {
				throw new NotFoundException("secret {} not found", uid);
			}
		} else {
			SecretEntity e = o.get();
			Secret secret = Jsons.transform(e, Secret.class);

			eventPublisher.publishEvent(new BeforeDeleteSecretEvent(secret));

			secretRepo.deleteById(uid);
			secretRepo.flush();

			logService.info(getClass(), secret.getUid(), Secret.class, null, null, "Deleted secret {}",
					secret.getCode());

			asyncExService.asyncRunAfterTxCommit(() -> {
				eventPublisher.publishEvent(new DeletedSecretEvent(secret));
			});
		}
	}

	@Override
	public long count() {
		return secretRepo.count();
	}

	@Override
	public String getContent(String uid) {
		Optional<SecretEntity> o = secretRepo.findById(uid);
		if (!o.isPresent()) {
			throw new NotFoundException("secret {} not found", uid);
		}
		String content = decryptContent(o.get().getEncryptedContent());
		return content;
	}

	@Override
	public String getSecret(String code) {
		Optional<SecretEntity> o = secretRepo.findByCode(code);
		if (!o.isPresent()) {
			throw new NotFoundException("secret {} not found", code);
		}
		String content = decryptContent(o.get().getEncryptedContent());
		return content;
	}

}